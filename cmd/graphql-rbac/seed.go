package main

import (
	"context"
	"errors"
	"graphql-rbac/internal/config"
	"graphql-rbac/internal/graphql/models"
	"graphql-rbac/internal/repository"
	"graphql-rbac/pkg/logger"
	"graphql-rbac/pkg/random"

	"github.com/gofrs/uuid"

	"go.uber.org/zap"
)

func seedDB(r repository.Repository, hashGenerator random.HashGenerator, cfg config.SeedConfig, log *logger.Logger) {
	ctx := context.Background()

	password, err := hashGenerator.Generate(cfg.SeedUserPassword)
	if err != nil {
		log.Fatal("can't generate password hash")
	}

	user := createUser(ctx, r, password, cfg, log)
	role := createRole(ctx, r, cfg, log)
	bindRoleToUser(ctx, r, user.ID, role.ID, log)
	createActions(ctx, r, log)
}

func createUser(ctx context.Context, r repository.Repository, password string, cfg config.SeedConfig, log *logger.Logger) *repository.User {
	user, err := r.Users().Create(ctx, cfg.SeedUserLogin, cfg.SeedUserLogin, cfg.SeedUserLogin, password)
	if err != nil {
		if errors.Is(err, repository.ErrUserLoginIsTaken) {
			log.Warn("seed user already exists", zap.String("login", user.Login))
			user, err = r.Users().GetByLogin(ctx, user.Login)
			if err != nil {
				log.Fatal("can't get user by login", zap.Error(err))
			}
		} else {
			log.Fatal("can't create seed user", zap.Error(err))
		}
	} else {
		log.Info("seed user created", zap.String("login", user.Login))
	}

	return user
}

func createRole(ctx context.Context, r repository.Repository, cfg config.SeedConfig, log *logger.Logger) *repository.Role {
	role, err := r.Roles().Create(ctx, cfg.SeedRoleTitle, cfg.SeedRoleTitle, cfg.SeedRoleSuper)
	if err != nil {
		if errors.Is(err, repository.ErrRoleTitleIsTaken) {
			log.Warn("seed role already exists", zap.String("title", role.Title))
			role, err = r.Roles().GetByTitle(ctx, role.Title)
			if err != nil {
				log.Fatal("can't get role by title", zap.Error(err))
			}
		} else {
			log.Fatal("can't create seed role", zap.Error(err))
		}
	} else {
		log.Info("seed role created", zap.String("title", role.Title))
	}

	return role
}

func bindRoleToUser(ctx context.Context, r repository.Repository, userID, roleID uuid.UUID, log *logger.Logger) {
	if err := r.Users().BindRole(ctx, userID, roleID); err != nil {
		if errors.Is(err, repository.ErrUserAlreadyBoundToRole) {
			log.Warn("role already bound to user")
		} else {
			log.Fatal("cant't bound role to user", zap.Error(err))
		}
	} else {
		log.Info("role bound to user")
	}
}

func createActions(ctx context.Context, r repository.Repository, log *logger.Logger) {
	actions := make([]*repository.Action, 0)
	offset := 0
	for {
		acts, err := r.Actions().Get(ctx, 500, offset)
		if err != nil {
			log.Fatal("can't get actions", zap.Error(err))
		}
		if len(acts) == 0 {
			break
		}
		actions = append(actions, acts...)
		offset += 500
	}

	actionsHashMap := make(map[string]struct{}, 0)
	for _, gqlAction := range models.AllAction {
		actionsHashMap[gqlAction.String()] = struct{}{}
	}

	for _, action := range actions {
		if _, ok := actionsHashMap[action.Title]; !ok {
			err := r.Actions().Delete(ctx, action.Title)
			if err != nil {
				log.Fatal("can't delete action", zap.Error(err))
			}
			log.Debug("deleted action", zap.String("title", action.Title))
		}
	}

	for action := range actionsHashMap {
		_, err := r.Actions().Create(ctx, action, "autogenerated")
		if err != nil {
			if errors.Is(err, repository.ErrActionTitleIsTaken) {
				continue
			}
			log.Fatal("can't create action", zap.Error(err))
		}
		log.Debug("created action", zap.String("title", action))
	}

	log.Info("actions actualized")
}
