package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
)

const (
	warn                 = "# Code generated by drctvgen.go, DO NOT EDIT.\n\n"
	enumStartDeclaration = "enum %s {\n"
	enumEndDeclaration   = "}\n"
)

// Creates file with graphql enum used in directives.
// Example:
// go run pkg/drctvgen/drctvgen.go -input=api/graphql/ -output=api/graphql/action.graphql -enum=Action -regex=(@auth.action:.)([A-Z]{2,10}_?)+ -prefix=@auth.action:.
// The latter command searches for all auth directive usage in api/graphql/
// and creates a new file named api/graphql/action.graphql
// with all enum variants necessary for auth directive sorted alphabetically

type parser struct {
	input  string
	output string
	enum   string
	regex  string
	prefix string
	suffix string

	r *regexp.Regexp
}

func parseArgs() *parser {
	p := &parser{}
	flag.StringVar(&p.input, "input", "", "required. path to input directory with graphql files")
	flag.StringVar(&p.output, "output", "", "required. path to output file")
	flag.StringVar(&p.enum, "enum", "", "required. graphql enum name")
	flag.StringVar(&p.regex, "regex", "", "required. regex for directive search")

	flag.StringVar(&p.prefix, "prefix", "", "prefix will be removed from result string (workaround for lookbehind)")
	flag.StringVar(&p.prefix, "suffix", "", "suffix will be removed from result string (workaround for lookahead)")

	flag.Parse()
	if p.input == "" || p.output == "" || p.enum == "" || p.regex == "" {
		log.Fatal("invalid params: flags should be specified")
	}
	p.r = regexp.MustCompile(p.regex)
	return p
}

func main() {
	p := parseArgs()

	lines := p.readFiles(p.input)
	outputFile, err := os.Create(p.output)
	if err != nil {
		log.Fatal(err)
	}

	p.writeToFile(outputFile, warn)
	p.writeToFile(outputFile, fmt.Sprintf(enumStartDeclaration, p.enum))
	for _, line := range lines {
		p.writeToFile(outputFile, line)
	}
	p.writeToFile(outputFile, enumEndDeclaration)

}

func (p *parser) writeToFile(file *os.File, data string) {
	_, err := file.Write([]byte(data))
	if err != nil {
		log.Fatal(err)
	}
}

func (p *parser) prepareLines(data []byte, lines []string) []string {
	res := p.r.FindAll(data, -1)
	resHash := make(map[string]struct{}, len(res))
	for _, r := range res {
		s := string(r)
		resHash[s[len(p.prefix):len(s)-len(p.suffix)]] = struct{}{}
	}

	for line := range resHash {
		// format line with 4 spaces indentation
		lines = append(lines, fmt.Sprintf("    %s\n", line))
	}

	return lines
}

func (p *parser) readFiles(path string) []string {
	files, err := ioutil.ReadDir(path)
	if err != nil {
		log.Fatal(err)
	}

	lines := make([]string, 0)

	for _, f := range files {
		// skip not "*.graphql*" files
		if !strings.Contains(f.Name(), ".graphql") {
			continue
		}

		data, err := ioutil.ReadFile(path + f.Name())
		if err != nil {
			log.Fatal(err)
		}
		lines = p.prepareLines(data, lines)
	}

	sort.Strings(lines)

	return lines
}
